diff --git a/src/chmap.rs b/src/chmap.rs
index b2c7592..0ecbeb1 100644
--- a/src/chmap.rs
+++ b/src/chmap.rs
@@ -14,7 +14,7 @@ alsa_enum!(
 
 alsa_enum!(
     /// [SND_CHMAP_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants
-    ChmapPosition, ALL_CHMAP_POSITIONS[33],
+    ChmapPosition, ALL_CHMAP_POSITIONS[37],
 
     Unknown = SND_CHMAP_UNKNOWN,
     NA = SND_CHMAP_NA,
@@ -22,6 +22,10 @@ alsa_enum!(
     FL = SND_CHMAP_FL,
     FR = SND_CHMAP_FR,
     RL = SND_CHMAP_RL,
+    RR = SND_CHMAP_RR,
+    FC = SND_CHMAP_FC,
+    LFE = SND_CHMAP_LFE,
+    SL = SND_CHMAP_SL,
     SR = SND_CHMAP_SR,
     RC = SND_CHMAP_RC,
     FLC = SND_CHMAP_FLC,
diff --git a/src/config.rs b/src/config.rs
new file mode 100644
index 0000000..b19d0aa
--- /dev/null
+++ b/src/config.rs
@@ -0,0 +1,43 @@
+//! Configuration file API
+//!
+//! For now, just contains functions regarding the global configuration
+//! stored as a cache inside alsa-lib. Calling `update_free_global` might help
+//! against valgrind reporting memory leaks.
+use crate::{alsa};
+use super::error::*;
+use super::Output;
+use std::ptr;
+
+pub fn update() -> Result<bool> {
+	acheck!(snd_config_update()).map(|x| x != 0)
+}
+
+pub fn update_free_global() -> Result<()> {
+	acheck!(snd_config_update_free_global()).map(|_| ())
+}
+
+/// [snd_config_t](https://alsa-project.org/alsa-doc/alsa-lib/group___config.html) wrapper
+pub struct Config(*mut alsa::snd_config_t);
+
+impl Drop for Config {
+    fn drop(&mut self) { unsafe { alsa::snd_config_unref(self.0) }; }
+}
+
+pub fn update_ref() -> Result<Config> {
+	let mut top = ptr::null_mut();
+	acheck!(snd_config_update_ref(&mut top)).map(|_| Config(top))
+}
+
+impl Config {
+    pub fn save(&self, o: &mut Output) -> Result<()> {
+        acheck!(snd_config_save(self.0, super::io::output_handle(o))).map(|_| ())
+    }
+}
+
+#[test]
+fn config_save() {
+	let c = update_ref().unwrap();
+    let mut outp = Output::buffer_open().unwrap();
+	c.save(&mut outp).unwrap();
+    println!("== Config save ==\n{}", outp);
+}
\ No newline at end of file
diff --git a/src/ctl_int.rs b/src/ctl_int.rs
index df42985..90465e3 100644
--- a/src/ctl_int.rs
+++ b/src/ctl_int.rs
@@ -105,6 +105,16 @@ impl Ctl {
         acheck!(snd_ctl_elem_unlock(self.0, elem_id_ptr(id)))
     }
 
+    pub fn elem_list(&self) -> Result<ElemList> {
+        // obtain the list of all the elements now that we know how many there are
+        let list = elem_list_new(|list| {
+            acheck!(snd_ctl_elem_list(self.0, list.0))?;
+            Ok(list.get_count())
+        })?;
+        acheck!(snd_ctl_elem_list(self.0, list.0))?;
+        Ok(list)
+    }
+
     /// Note: According to alsa-lib documentation, you're also supposed to have functionality for
     /// returning whether or not you are subscribed. This does not work in practice, so I'm not
     /// including that here.
@@ -448,6 +458,58 @@ impl fmt::Debug for ElemId {
     }
 }
 
+/// [snd_ctl_elem_list_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper
+pub struct ElemList(*mut alsa::snd_ctl_elem_list_t);
+
+impl Drop for ElemList {
+    fn drop(&mut self) {
+        unsafe { alsa::snd_ctl_elem_list_free_space(self.0) };
+        unsafe { alsa::snd_ctl_elem_list_free(self.0) };
+    }
+}
+
+fn elem_list_new<F: FnOnce(&ElemList) -> Result<u32>>(f: F) -> Result<ElemList> {
+    let mut p = ptr::null_mut();
+    let list = acheck!(snd_ctl_elem_list_malloc(&mut p)).map(|_| ElemList(p))?;
+    let count = f(&list)?;
+    if count > 0 {
+        acheck!(snd_ctl_elem_list_alloc_space(list.0, count))?;
+    }
+    Ok(list)
+}
+
+impl ElemList {
+    #[inline]
+    fn ensure_valid_index(&self, index: u32) -> Result<()> {
+        if index >= self.get_used() {
+            Err(Error::new("snd_ctl_elem_list_*", libc::EINVAL))
+        } else {
+            Ok(())
+        }
+    }
+
+    pub(crate) fn get_count(&self) -> u32 { unsafe { alsa::snd_ctl_elem_list_get_count(self.0) } }
+    pub fn get_used(&self) -> u32 { unsafe { alsa::snd_ctl_elem_list_get_used(self.0) } }
+    pub fn get_id(&self, index: u32) -> Result<ElemId> {
+        self.ensure_valid_index(index)?;
+        let elem_id = elem_id_new()?;
+        unsafe { alsa::snd_ctl_elem_list_get_id(self.0, index, elem_id_ptr(&elem_id)) };
+        Ok(elem_id)
+    }
+    pub fn get_numid(&self, index: u32) -> Result<u32> { self.ensure_valid_index(index)?; Ok(unsafe { alsa::snd_ctl_elem_list_get_numid(self.0, index) }) }
+    pub fn get_interface(&self, index: u32) -> Result<ElemIface> {
+        self.ensure_valid_index(index)?;
+        ElemIface::from_c_int(unsafe { alsa::snd_ctl_elem_list_get_interface(self.0, index) } as c_int, "snd_ctl_elem_list_get_interface")
+    }
+    pub fn get_device(&self, index: u32) -> Result<u32> { self.ensure_valid_index(index)?; Ok(unsafe { alsa::snd_ctl_elem_list_get_device(self.0, index) }) }
+    pub fn get_subdevice(&self, index: u32) -> Result<u32> { self.ensure_valid_index(index)?; Ok(unsafe { alsa::snd_ctl_elem_list_get_subdevice(self.0, index) }) }
+    pub fn get_name(&self, index: u32) -> Result<&str> {
+        self.ensure_valid_index(index)?;
+        from_const("snd_ctl_elem_list_get_name", unsafe { alsa::snd_ctl_elem_list_get_name(self.0, index) })
+    }
+    pub fn get_index(&self, index: u32) -> Result<u32> { self.ensure_valid_index(index)?; Ok(unsafe { alsa::snd_ctl_elem_list_get_index(self.0, index) }) }
+}
+
 /// [snd_ctl_event_t](http://www.alsa-project.org/alsa-doc/alsa-lib/group___control.html) wrapper
 pub struct Event(*mut alsa::snd_ctl_event_t);
 
diff --git a/src/io.rs b/src/io.rs
index f6c3739..de80827 100644
--- a/src/io.rs
+++ b/src/io.rs
@@ -22,7 +22,7 @@ impl Output {
         let b = unsafe {
             let mut q = ptr::null_mut();
             let s = alsa::snd_output_buffer_string(self.0, &mut q);
-            slice::from_raw_parts(q as *const u8, s as usize)
+            if s == 0 { &[] } else { slice::from_raw_parts(q as *const u8, s as usize) }
         };
         f(b)
     }
diff --git a/src/lib.rs b/src/lib.rs
index 7bcfcdc..81ca0f0 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -99,7 +99,7 @@ pub use crate::card::Card as Card;
 mod ctl_int;
 pub mod ctl {
     //! Control device API
-    pub use super::ctl_int::{Ctl, CardInfo, DeviceIter, ElemIface, ElemId, ElemType, ElemValue, ElemInfo};
+    pub use super::ctl_int::{Ctl, CardInfo, DeviceIter, ElemIface, ElemId, ElemList, ElemType, ElemValue, ElemInfo};
 }
 
 pub use crate::ctl::Ctl as Ctl;
@@ -110,6 +110,8 @@ pub use crate::hctl::HCtl as HCtl;
 pub mod pcm;
 pub use crate::pcm::PCM as PCM;
 
+pub mod config;
+
 pub mod rawmidi;
 pub use crate::rawmidi::Rawmidi as Rawmidi;
 
diff --git a/src/pcm.rs b/src/pcm.rs
index 16569b7..4c15061 100644
--- a/src/pcm.rs
+++ b/src/pcm.rs
@@ -230,13 +230,18 @@ impl PCM {
     pub fn io_f32(&self) -> Result<IO<f32>> { self.io_checked() }
     pub fn io_f64(&self) -> Result<IO<f64>> { self.io_checked() }
 
+    /// For the `s24` format, represented by i32
+    pub fn io_i32_s24(&self) -> Result<IO<i32>> { self.verify_format(Format::s24()).map(|_| IO::new(self)) }
+    /// For the `u24` format, represented by u32
+    pub fn io_u32_u24(&self) -> Result<IO<u32>> { self.verify_format(Format::u24()).map(|_| IO::new(self)) }
+
     pub fn io_checked<S: IoFormat>(&self) -> Result<IO<S>> {
         self.verify_format(S::FORMAT).map(|_| IO::new(self))
     }
 
-    /// Creates IO without checking [`S`] is valid type.
+    /// Creates IO without checking `S` is valid type.
     ///
-    /// SAFETY: Caller must guarantee [`S`] is valid type for this PCM stream
+    /// SAFETY: Caller must guarantee `S` is valid type for this PCM stream
     /// and that no other IO objects exist at the same time for the same stream
     /// (or in some other way guarantee mmap safety)
     pub unsafe fn io_unchecked<S: IoFormat>(&self) -> IO<S> {
@@ -245,6 +250,10 @@ impl PCM {
 
     #[deprecated(note = "renamed to io_bytes")]
     pub fn io(&self) -> IO<u8> { IO::new(self) }
+
+    /// Call this if you have an unusual format, not supported by the regular access methods
+    /// (io_i16 etc). It will succeed regardless of the sample format, but conversion to and from
+    /// bytes to your format is up to you.
     pub fn io_bytes(&self) -> IO<u8> { IO::new(self) }
 
     /// Read buffers by talking to the kernel directly, bypassing alsa-lib.
@@ -362,7 +371,7 @@ impl<'a, S: Copy> Drop for IO<'a, S> {
 
 impl<'a, S: Copy> IO<'a, S> {
 
-    fn new(a: &'a PCM) -> IO<'a, S> {
+    pub fn new(a: &'a PCM) -> IO<'a, S> {
         a.check_has_io();
         a.1.set(true);
         IO(a, PhantomData)
@@ -466,7 +475,7 @@ alsa_enum!(
 alsa_enum!(
     #[non_exhaustive]
     /// [SND_PCM_FORMAT_xxx](http://www.alsa-project.org/alsa-doc/alsa-lib/group___p_c_m.html) constants
-    Format, ALL_FORMATS[48],
+    Format, ALL_FORMATS[52],
 
     Unknown = SND_PCM_FORMAT_UNKNOWN,
     S8 = SND_PCM_FORMAT_S8,
@@ -494,6 +503,10 @@ alsa_enum!(
     ImaAdPCM = SND_PCM_FORMAT_IMA_ADPCM,
     MPEG = SND_PCM_FORMAT_MPEG,
     GSM = SND_PCM_FORMAT_GSM,
+    S20LE = SND_PCM_FORMAT_S20_LE,
+    S20BE = SND_PCM_FORMAT_S20_BE,
+    U20LE = SND_PCM_FORMAT_U20_LE,
+    U20BE = SND_PCM_FORMAT_U20_BE,
     Special = SND_PCM_FORMAT_SPECIAL,
     S243LE = SND_PCM_FORMAT_S24_3LE,
     S243BE = SND_PCM_FORMAT_S24_3BE,
@@ -547,6 +560,10 @@ impl fmt::Display for Format {
             ImaAdPCM => write!(f, "IMA_ADPCM"),
             MPEG => write!(f, "MPEG"),
             GSM => write!(f, "GSM"),
+            S20LE => write!(f, "S20_LE"),
+            S20BE => write!(f, "S20_BE"),
+            U20LE => write!(f, "U20_LE"),
+            U20BE => write!(f, "U20_BE"),
             Special => write!(f, "SPECIAL"),
             S243LE => write!(f, "S24_3LE"),
             S243BE => write!(f, "S24_3BE"),
@@ -605,6 +622,10 @@ impl FromStr for Format {
             "IMA_ADPCM" => ImaAdPCM,
             "MPEG" => MPEG,
             "GSM" => GSM,
+            "S20_LE" => S20LE,
+            "S20_BE" => S20BE,
+            "U20_LE" => U20LE,
+            "U20_BE" => U20BE,
             "SPECIAL" => Special,
             "S24_3LE" => S243LE,
             "S24_3BE" => S243BE,
@@ -652,9 +673,15 @@ impl Format {
     #[cfg(target_endian = "little")] pub const fn u24_3() -> Format { Format::U243LE }
     #[cfg(target_endian = "big")] pub const fn u24_3() -> Format { Format::U243BE }
 
+    #[cfg(target_endian = "little")] pub const fn s20() -> Format { Format::S20LE }
+    #[cfg(target_endian = "big")] pub const fn s20() -> Format { Format::S20BE }
+
     #[cfg(target_endian = "little")] pub const fn s20_3() -> Format { Format::S203LE }
     #[cfg(target_endian = "big")] pub const fn s20_3() -> Format { Format::S203BE }
 
+    #[cfg(target_endian = "little")] pub const fn u20() -> Format { Format::U20LE }
+    #[cfg(target_endian = "big")] pub const fn u20() -> Format { Format::U20BE }
+
     #[cfg(target_endian = "little")] pub const fn u20_3() -> Format { Format::U203LE }
     #[cfg(target_endian = "big")] pub const fn u20_3() -> Format { Format::U203BE }
 
@@ -859,6 +886,10 @@ impl<'a> HwParams<'a> {
         acheck!(snd_pcm_hw_params_test_format((self.1).0, self.0, v as c_int)).map(|_| ())
     }
 
+    pub fn test_access(&self, v: Access) -> Result<()> {
+        acheck!(snd_pcm_hw_params_test_access((self.1).0, self.0, v as c_uint)).map(|_| ())
+    }
+
     pub fn set_access(&self, v: Access) -> Result<()> {
         acheck!(snd_pcm_hw_params_set_access((self.1).0, self.0, v as c_uint)).map(|_| ())
     }
@@ -1218,6 +1249,19 @@ fn record_from_default() {
     assert_eq!(pcm.io_i16().unwrap().readi(&mut buf).unwrap(), 1024/2);
 }
 
+#[test]
+fn open_s24() {
+    let pcm = PCM::open(c"default", Direction::Playback, false).unwrap();
+    let hwp = HwParams::any(&pcm).unwrap();
+    hwp.set_channels(1).unwrap();
+    hwp.set_rate(44100, ValueOr::Nearest).unwrap();
+    hwp.set_format(Format::s24()).unwrap();
+    hwp.set_access(Access::RWInterleaved).unwrap();
+    pcm.hw_params(&hwp).unwrap();
+    assert_eq!(Format::s24().physical_width(), Ok(32));
+    let _io = pcm.io_i32_s24().unwrap();
+}
+
 #[test]
 fn playback_to_default() {
     use std::ffi::CString;
